import requests
import time
from datetime import datetime
import sqlite3
import logging

def fetch_cpe_names():
    conn = sqlite3.connect('data/devices.db')
    cursor = conn.cursor()
    cursor.execute("SELECT id, device_type, cpe_name FROM CPE WHERE cpe_name IS NOT NULL")
    items = cursor.fetchall()
    conn.close()
    return items

logging.basicConfig(level=logging.DEBUG, filename='app.log', filemode='a',
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

def fetch_cve_details(cpe_name):
    logger = logging.getLogger('fetch_cve_details')
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName={cpe_name}"
    wait_time = 60
    while True:
        response = requests.get(url)
        if response.status_code == 200:
            logger.info(f"Successful data retrieval for {cpe_name}")
            return response.json()
        elif response.status_code == 403:
            logger.warning(f"Access Forbidden (status 403). Retrying after {wait_time} seconds...")
            time.sleep(wait_time)
        else:
            logger.error(f"Failed to fetch data: {response.status_code} - {response.text}")
            return None


def update_vulnerabilities(cve_data, device_id, device_type, cpe_name):
    if not cve_data or 'vulnerabilities' not in cve_data:
        print(f"No CVE data to process for {cpe_name}.")
        return
    

    for vulnerability in cve_data['vulnerabilities']:
        cve_id = vulnerability['cve']['id']
        description = vulnerability['cve']['descriptions'][0]['value']
        print(f"Processing CVE ID: {cve_id} with description: {description}")

    conn = sqlite3.connect('data/devices.db')
    cursor = conn.cursor()
    insert_sql = '''
    INSERT INTO vulnerabilities (
        id, unique_id, device_type, cpe_name, cve_id, source_identifier, published, last_modified, 
        vuln_status, description, cvss_score, severity, attack_vector, attack_complexity, 
        privileges_required, user_interaction, scope, confidentiality_impact, integrity_impact, 
        availability_impact, exploitability_score, impact_score)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON CONFLICT(unique_id) DO UPDATE SET
        source_identifier=excluded.source_identifier,
        published=excluded.published,
        last_modified=excluded.last_modified,
        vuln_status=excluded.vuln_status,
        description=excluded.description,
        cvss_score=excluded.cvss_score,
        severity=excluded.severity,
        attack_vector=excluded.attack_vector,
        attack_complexity=excluded.attack_complexity,
        privileges_required=excluded.privileges_required,
        user_interaction=excluded.user_interaction,
        scope=excluded.scope,
        confidentiality_impact=excluded.confidentiality_impact,
        integrity_impact=excluded.integrity_impact,
        availability_impact=excluded.availability_impact,
        exploitability_score=excluded.exploitability_score,
        impact_score=excluded.impact_score
    '''

    try:
        for vulnerability in cve_data['vulnerabilities']:
            cve_id = vulnerability['cve']['id']
            unique_id = f"{device_id}-{cve_id}"
            source_identifier = vulnerability['cve']['sourceIdentifier']
            description = vulnerability['cve']['descriptions'][0]['value']
            published = datetime.strptime(vulnerability['cve']['published'], '%Y-%m-%dT%H:%M:%S.%f')
            last_modified = datetime.strptime(vulnerability['cve']['lastModified'], '%Y-%m-%dT%H:%M:%S.%f')
            vuln_status = vulnerability['cve']['vulnStatus']
            
            if 'cvssMetricV31' in vulnerability['cve']['metrics']:
                cvss_metrics = vulnerability['cve']['metrics']['cvssMetricV31'][0]['cvssData']
            elif 'cvssMetricV30' in vulnerability['cve']['metrics']:
                cvss_metrics = vulnerability['cve']['metrics']['cvssMetricV30'][0]['cvssData']    
            cvss_score = float(cvss_metrics['baseScore'])
            severity = cvss_metrics['baseSeverity']
            attack_vector = cvss_metrics.get('attackVector', 'UNKNOWN')
            attack_complexity = cvss_metrics.get('attackComplexity', 'UNKNOWN')
            privileges_required = cvss_metrics.get('privilegesRequired', 'UNKNOWN')
            user_interaction = cvss_metrics.get('userInteraction', 'UNKNOWN')
            scope = cvss_metrics.get('scope', 'UNKNOWN')
            confidentiality_impact = cvss_metrics.get('confidentialityImpact', 'UNKNOWN')
            integrity_impact = cvss_metrics.get('integrityImpact', 'UNKNOWN')
            availability_impact = cvss_metrics.get('availabilityImpact', 'UNKNOWN')
            exploitability_score = cvss_metrics.get('exploitabilityScore', 0.0)  # These might need proper parsing
            impact_score = cvss_metrics.get('impactScore', 0.0)
    
            cursor.execute(insert_sql, (device_id, unique_id, device_type, cpe_name, cve_id, source_identifier, published, last_modified,
                                        vuln_status, description, cvss_score, severity, attack_vector, attack_complexity, 
                                        privileges_required, user_interaction, scope, confidentiality_impact, integrity_impact, 
                                        availability_impact, exploitability_score, impact_score))
        conn.commit()  
        print("CVE details updated successfully.")
    except sqlite3.Error as e:
        print(f"An error occurred: {e}")
        conn.rollback()
    finally:
        conn.close()

def delete_null_cve_entries():
    conn = sqlite3.connect('data/devices.db')
    cursor = conn.cursor()


    delete_sql = 'DELETE FROM vulnerabilities WHERE cve_id IS NULL'

    try:
        cursor.execute(delete_sql)
        conn.commit()  
        print("Entries with NULL CVE ID deleted successfully.")
    except sqlite3.Error as e:
        print(f"An error occurred while deleting entries: {e}")
        conn.rollback()  
    finally:
        conn.close() 

import sqlite3
import json

def add_vulnerability_details_to_gemini(device_type=None, cve_id=None):
    # Define the default paths
    db_path = 'data/devices.db'
    gemini_json_path = '/data/gemini.json'
    
    # Connect to the database
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # Build the query based on provided filters
    query = "SELECT * FROM vulnerabilities WHERE 1=1"
    params = []
    
    if device_type:
        query += " AND device_type = ?"
        params.append(device_type)
    
    if cve_id:
        query += " AND cve_id = ?"
        params.append(cve_id)
    
    cursor.execute(query, params)
    vulnerabilities = cursor.fetchall()
    
    # Define the column names based on the table schema
    columns = [
        "id", "unique_id", "device_type", "cpe_name", "cve_id", "source_identifier", "published", 
        "last_modified", "vuln_status", "description", "cvss_score", "severity", "attack_vector", 
        "attack_complexity", "privileges_required", "user_interaction", "scope", 
        "confidentiality_impact", "integrity_impact", "availability_impact", 
        "exploitability_score", "impact_score"
    ]
    
    # Format the vulnerability details
    vulnerabilities_details = []
    for row in vulnerabilities:
        vulnerabilities_details.append(dict(zip(columns, row)))
    
    # Load the existing JSON data
    with open(gemini_json_path, 'r') as file:
        gemini_data = json.load(file)
    
    # Create the vulnerability output structure
    vulnerabilities_output = {
        "Vulnerability Details": vulnerabilities_details
    }
    
    # Add the output to the existing Gemini JSON data
    if "Vulnerabilities" not in gemini_data["Outputs"]:
        gemini_data["Outputs"]["Vulnerabilities"] = []
    
    gemini_data["Outputs"]["Vulnerabilities"].append(vulnerabilities_output)
    
    # Save the updated JSON data back to the file
    with open(gemini_json_path, 'w') as file:
        json.dump(gemini_data, file, indent=4)
    
    # Close the database connection
    conn.close()
    
    print(f"Vulnerability details added to {gemini_json_path}")

import os

def add_vulnerability_details_to_gemini():
    # Define the default paths
    db_path = 'data/devices.db'
    gemini_json_path = 'data/gemini.json'
    
    # Check if the JSON file exists; if not, create it
    if not os.path.exists(gemini_json_path):
        # Initialize the JSON structure
        gemini_data = {
            "Outputs": {
                "Vulnerabilities": []
            }
        }
        # Create the file with the initial structure
        with open(gemini_json_path, 'w') as file:
            json.dump(gemini_data, file, indent=4)
        print(f"{gemini_json_path} created.")
    else:
        # Load the existing JSON data
        with open(gemini_json_path, 'r') as file:
            gemini_data = json.load(file)
    
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    query = "SELECT * FROM vulnerabilities"
    cursor.execute(query)
    vulnerabilities = cursor.fetchall()
    
    columns = [
        "id", "unique_id", "device_type", "cpe_name", "cve_id", "source_identifier", "published", 
        "last_modified", "vuln_status", "description", "cvss_score", "severity", "attack_vector", 
        "attack_complexity", "privileges_required", "user_interaction", "scope", 
        "confidentiality_impact", "integrity_impact", "availability_impact", 
        "exploitability_score", "impact_score"
    ]
    
    vulnerabilities_details = []
    for row in vulnerabilities:
        vulnerabilities_details.append(dict(zip(columns, row)))
    
    vulnerabilities_output = {
        "Vulnerability Details": vulnerabilities_details
    }
    
    gemini_data["Outputs"]["Vulnerabilities"].append(vulnerabilities_output)
    
    with open(gemini_json_path, 'w') as file:
        json.dump(gemini_data, file, indent=4)
    
    conn.close()
    
    print(f"All vulnerability details added to {gemini_json_path}")

def main():
    api_key = 'ef63d53f-427e-483b-ba41-753895affec4'
    cpe_items = fetch_cpe_names()
    for device_id, device_type, cpe_name in cpe_items:
        cve_response = fetch_cve_details(cpe_name)
        print(cve_response)
        if cve_response:
            update_vulnerabilities(cve_response, device_id, device_type, cpe_name)

if __name__ == "__main__":
    main()
    add_vulnerability_details_to_gemini()
